package servemux

import (
	"crypto/tls"
	"io"
	"log"
	"net"
	"net/http"
	"net/url"
	"strings"
)

type WsReverseProxy struct {
	//  Dialer contains options for connecting to the backend WebSocket server.
	//  If nil, DefaultDialer net..Dial is used.
	Dialer func(network, addr string) (net.Conn, error)

	// Director must be a function which modifies
	// the request into a new request to be sent
	// using Transport.
	Director func(*http.Request)

	// TLSClientConfig specifies the TLS configuration to use with
	// tls.Client.
	TLSClientConfig *tls.Config
}

func NewSingleHostWsReverseProxy(target *url.URL) *WsReverseProxy {
	targetQuery := target.RawQuery
	director := func(req *http.Request) {
		req.Host = target.Scheme
		req.URL.Scheme = target.Scheme
		req.URL.Host = target.Host
		req.URL.Path = SingleJoiningSlash(target.Path, req.URL.Path)
		if targetQuery == "" || req.URL.RawQuery == "" {
			req.URL.RawQuery = targetQuery + req.URL.RawQuery
		} else {
			req.URL.RawQuery = targetQuery + "&" + req.URL.RawQuery
		}
	}

	return &WsReverseProxy{Director: director}

}

func (ws *WsReverseProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if !isWebsocketRequest(r) {
		http.Error(w, "the request is not websocket", http.StatusInternalServerError)
		return
	}

	outreq := r.Clone(r.Context())
	ws.Director(outreq)

	if clientIP, _, err := net.SplitHostPort(r.RemoteAddr); err == nil {
		// If we aren't the first proxy retain prior
		// X-Forwarded-For information as a comma+space
		// separated list and fold multiple headers into one.
		prior, ok := outreq.Header["X-Forwarded-For"]
		omit := ok && prior == nil // Issue 38079: nil now means don't populate the header
		if len(prior) > 0 {
			clientIP = strings.Join(prior, ", ") + ", " + clientIP
		}
		if !omit {
			outreq.Header.Set("X-Forwarded-For", clientIP)
		}
	}

	dial := ws.Dialer
	if dial == nil {
		dial = net.Dial
	}

	host := outreq.URL.Host
	if !strings.Contains(host, ":") {
		if outreq.URL.Scheme == "wws" {
			host = host + ":443"
		} else {
			host = host + ":80"
		}
	}

	if outreq.URL.Scheme == "wws" {
		tlsConfig := new(tls.Config)
		if ws.TLSClientConfig != nil {
			tlsConfig = ws.TLSClientConfig
		}
		dial = func(network, address string) (net.Conn, error) {
			return tls.Dial("tcp", host, tlsConfig)
		}
	}

	d, err := dial("tcp", host)
	if err != nil {
		http.Error(w, "dial connect websocket error", http.StatusInternalServerError)
		return
	}

	// all request generated by the http package implement this interface
	hj, ok := w.(http.Hijacker)
	if !ok {
		http.Error(w, "not a Hijacker", http.StatusInternalServerError)
		return
	}
	// Hijack lets the caller take over the connection.
	// After a call to Hijack the HTTP server library
	// will not do anything else with the connection.
	//
	con, _, err := hj.Hijack()
	if err != nil {
		log.Printf("Hijack error")
		return
	}

	defer d.Close()

	defer con.Close()

	if err = outreq.Write(d); err != nil {
		log.Printf("error copying request to taaget: %v", err)
		return
	}

	errCh := make(chan error, 2)
	cp := func(dst io.Writer, src io.Reader) {
		_, err := io.Copy(dst, src)
		errCh <- err
	}
	go cp(d, con)
	go cp(con, d)
	<-errCh

}

func isWebsocketRequest(req *http.Request) bool {
	contains := func(key, value string) bool {
		valList := strings.Split(req.Header.Get(key), ",")
		for _, v := range valList {
			if value == strings.ToLower(strings.TrimSpace(v)) {
				return true
			}
		}
		return false
	}

	if !contains("Connection", "upgrade") {
		return false
	}
	if !contains("Upgrade", "websocket") {
		return false
	}

	return true
}

func SingleJoiningSlash(a, b string) string {
	aslash := strings.HasSuffix(a, "/")
	bslash := strings.HasPrefix(b, "/")
	switch {
	case aslash && bslash:
		return a + b[1:]
	case !aslash && !bslash:
		return a + "/" + b
	}
	return a + b
}
